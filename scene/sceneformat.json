// Notes:
//  - Vector = [X, Y, Z] = [float, float, float] any float value is accepted
//  - Color = [R, G, B] = [float, float, float] values between 0.0 and 1.0
{
  "Render": {
    "Camera": {
      "ImageWidth": int,
      "ImageHeight": int,
      // Camera position
      "Position": Vector,
      // What point the camera is looking at
      "LookAt": Vector,
      // The upward direction of the camera
      "UpDir": Vector, // Default: [0, 1, 0]
      // Field of view in degrees
      "FOV": float, // Default: 53
      // Background color
      "Background": Color

    },
    // Max depth of reflection/refraction, if AdaptiveThreshold isn't hit
    "MaxDepth": int,
    // Stop reflection/refraction if contribution is below this value
    "AdaptiveThreshold": float,
    // Antialiasing is enabled if AAThreshold is > 0. If enabled, 4 primary rays are
    // used per pixel and if the difference in color is above AAThreshold then each
    // of the 4 subpixels is divided and repeated, until at most AAMAxDivisions
    // subdivisions
    "AAMaxDivisions": int,
    "AAThreshold": float,
    // Color of the scene's ambient light
    "AmbientLight": Color,
    "DirectionalLights": [
      {
        "Color": Color
        "Orientation": Vector,
      },
      ...
    ],
    "PointLights": [
      {
        "Color": Color,
        "Position": Vetor,
        "ConstCoeff": float,
        "LinearCoeff": float,
        "QuadCoeff": float
      },
      ...
    ],
    "SpotLights": [
      {
        "Color": Color
        "Position": Vector
        "Orientation": Vector,
        "Angle": float, // Degrees
        "DropOff": float,
        "FadeAngle": float
      },
      // A square light source that casts soft shadows
      "AreaLights": [
      {
        "Color": Color
        "Position": Vector
        "Orientation": Vector,
        "UpDir": Vector,
        "Size": float, // The width and height
        "Samples": int // Sqrt(#samples you want)
        "ConstCoeff": float,
        "LinearCoeff": float,
        "QuadCoeff": float,
        "Accelerated": bool // Faster but slightly less accurate sometimes
      },
    ]
  },
  "Materials": [
    {
      "Name": string,
      "Emissive": Color,
      // Textures are png or jpeg images. Specify the file name here relative to
      // the texture directory. If both a texture and a constant value is specified
      // then only the texture is used.
      "EmissiveTextureFile": string,
      "Ambient": Color,
      "AmbientTextureFile": string,
      "Specular": Color,
      "SpecularTextureFile": string,
      "Reflective": Color,
      "ReflectiveTextureFile": string,
      "Diffuse": Color,
      "DiffuseTextureFile": string,
      "Transmissive": Color,
      "TransmissiveTextureFile": string
      "Shininess": float,
      // For the Shininess and Index textures only the R value of the colors is used.
      "ShininessTextureFile": string,
      "Index": float, // Default: refractive index of air
      "IndexTextureFile": string
    },
    ... // Any number of materials, each with a unique "Name"
  ],
  "Scene": [
    {
      // Transform type affects all SubObjects and may be nested
      "Type": "Transform",
      "Properties": {
        "Translate": Vector,
        // Axis to rotate round
        "RotateAxis": Vector,
        // Degrees to rotate
        "RotateAngle": float,
        "Scale": Vector // Default: [1, 1, 1]
      },
      "SubObjects": [
        {
          // Unit sphere, use transforms to change size and position
          "Type": "Sphere",
          "Properties": {
            // The "Name" of one of the Materials above
            "Material": string
          }
        },
        {
          // Cube of side length 1
          "Type": "Box",
          "Properties": {
            "Material": string
          }
        },
        {
          // Unit square in the XY plane
          "Type": "Square",
          "Properties": {
            "Material": string
          }
        },
        {
          // 3-sided polygon. The clockwise direction of the points is A -> B -> C
          "Type": "Triangle",
          "Properties": {
            "Material": string,
            "PointA": Vector,
            "PointB": Vector,
            "PointC": Vector
          }
        },
        ... // Other objects (possibly including nested trasforms)
      ]
    },
    ... // Other objects at the top level
  ]
}
